---
import AdminLayout from "@layouts/AdminLayout.astro";
import Modal from "@components/Modal.astro";
import Button from "@components/ui/Button.astro";
import { Toggle } from "@components/ui/Toggle";
import { Lock } from "lucide-react";
import { getImageBaseUrl } from "@lib/paths";
import fs from "fs/promises";
import yaml from "js-yaml";
import { getSettingsFilePath } from "@lib/config-paths";

const imageBaseUrl = getImageBaseUrl();
let publishOnImportDefault = false;

try {
  const content = await fs.readFile(getSettingsFilePath(), "utf-8");
  const settings = yaml.load(content) as any;
  publishOnImportDefault = settings?.gallery?.publishOnImport === true;
} catch (e) {
  console.error("Failed to load settings:", e);
}
---

<AdminLayout title="Upload Images">
  <div class="space-y-6" data-testid="upload-page">
    <!-- Back link -->
    <a
      href="/gallery"
      class="text-admin-muted hover:text-admin-text"
      data-testid="back-to-gallery">‚Üê Go to Gallery</a
    >

    <!-- Collapsible: Image Upload Section -->
    <div id="upload-section" class="collapsible-section">
      <!-- Minimal collapsed form -->
      <div
        class="collapsible-header card border-2 border-dashed border-admin-border hover:border-admin-accent cursor-pointer flex items-center gap-4 p-4"
        data-collapse="upload"
      >
        <span class="text-2xl">üì§</span>
        <span class="text-lg font-semibold flex-1">Drop images here</span>
        <button
          type="button"
          class="collapse-toggle p-1 hover:bg-admin-bg rounded transition-colors"
        >
          <svg
            class="w-5 h-5 text-admin-muted collapse-chevron transition-transform flex-shrink-0"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M19 9l-7 7-7-7"></path>
          </svg>
        </button>
      </div>

      <!-- Expanded content -->
      <div class="collapsible-content mt-0">
        <div
          id="drop-zone"
          class="card border-2 border-dashed border-admin-border hover:border-admin-accent transition-colors cursor-pointer h-full flex flex-col justify-center relative"
          data-testid="drop-zone"
        >
          <button
            type="button"
            class="collapse-toggle absolute top-4 right-4 z-10 p-2 hover:bg-admin-bg rounded transition-colors"
            title="Collapse"
          >
            <svg
              class="w-5 h-5 text-admin-muted"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M5 15l7-7 7 7"></path>
            </svg>
          </button>
          <div class="text-center py-16">
            <div class="text-6xl mb-4">üì§</div>
            <h2 class="text-xl font-semibold mb-2">Drop images here</h2>
            <p class="text-admin-muted mb-4">or click to select files</p>
            <p class="text-sm text-admin-muted">
              Supports: JPG, PNG, TIFF, HEIC, WebP (max 50MB each)
            </p>
            <input
              type="file"
              id="file-input"
              multiple
              accept=".jpg,.jpeg,.png,.tiff,.tif,.heic,.heif,.webp"
              class="hidden"
              data-testid="file-input"
            />
          </div>
        </div>
      </div>
    </div>

    <!-- Collapsible: FTP/SFTP Upload Section -->
    <div id="ftp-section" class="collapsible-section collapsed">
      <!-- Minimal collapsed form -->
      <div
        class="collapsible-header card bg-admin-sidebar flex items-center gap-4 p-4"
        data-collapse="ftp"
      >
        <span class="text-2xl">üí°</span>
        <span class="text-lg font-semibold flex-1"
          >Bulk Upload via FTP/SFTP</span
        >
        <div class="flex items-center gap-2">
          <button
            id="scan-images-btn-collapsed"
            class="btn btn-secondary text-sm py-1.5"
          >
            üîç Scan for New Images
          </button>
          <button
            id="show-ftp-details-collapsed"
            class="text-sm text-admin-muted hover:text-admin-text py-1.5"
          >
            Show details
          </button>
        </div>
        <button
          type="button"
          class="collapse-toggle p-1 hover:bg-admin-bg rounded transition-colors"
        >
          <svg
            class="w-5 h-5 text-admin-muted collapse-chevron transition-transform flex-shrink-0"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M19 9l-7 7-7-7"></path>
          </svg>
        </button>
      </div>

      <!-- Expanded content -->
      <div class="collapsible-content mt-0">
        <div class="card bg-admin-sidebar h-full relative">
          <button
            type="button"
            class="collapse-toggle absolute top-4 right-4 z-10 p-2 hover:bg-admin-bg rounded transition-colors"
            title="Collapse"
          >
            <svg
              class="w-5 h-5 text-admin-muted"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M5 15l7-7 7 7"></path>
            </svg>
          </button>
          <div class="flex items-start gap-4">
            <div class="text-3xl">üí°</div>
            <div>
              <h3 class="font-semibold mb-2">Bulk Upload via FTP/SFTP</h3>
              <p class="text-sm text-admin-muted mb-3">
                For uploading many large files, you can use FTP or SFTP to
                transfer images directly to the server. This is faster and more
                reliable for large batches.
              </p>

              <div class="bg-admin-bg rounded-lg p-4 mb-3">
                <h4 class="text-sm font-medium mb-2">Upload Steps:</h4>
                <ol
                  class="text-sm text-admin-muted space-y-2 list-decimal list-inside"
                >
                  <li>
                    Connect to your server via FTP/SFTP client (FileZilla,
                    Cyberduck, etc.)
                  </li>
                  <li>
                    Navigate to: <code
                      class="bg-admin-card px-1.5 py-0.5 rounded"
                      >files/originals/</code
                    >
                  </li>
                  <li>
                    Upload your image files (name them as the artwork slug,
                    e.g., <code class="bg-admin-card px-1.5 py-0.5 rounded"
                      >my-artwork.jpg</code
                    >)
                  </li>
                  <li>
                    Return here and click <strong>"Scan for New Images"</strong> below
                  </li>
                  <li>Process the images to generate web-optimized versions</li>
                </ol>
              </div>

              <div class="flex gap-4">
                <button id="scan-images-btn" class="btn btn-secondary text-sm">
                  üîç Scan for New Images
                </button>
                <button
                  id="show-ftp-details"
                  class="text-sm text-admin-muted hover:text-admin-text"
                >
                  Show connection details
                </button>
              </div>

              <div
                id="ftp-details"
                class="hidden mt-4 bg-admin-bg rounded-lg p-4"
              >
                <h4 class="text-sm font-medium mb-2">Connection Details:</h4>
                <div class="grid grid-cols-2 gap-2 text-sm">
                  <div class="text-admin-muted">Protocol:</div>
                  <div>SFTP (recommended)</div>
                  <div class="text-admin-muted">Host:</div>
                  <div>
                    <code class="bg-admin-card px-1.5 py-0.5 rounded"
                      >your-server.com</code
                    >
                  </div>
                  <div class="text-admin-muted">Port:</div>
                  <div>22 (SFTP) or 21 (FTP)</div>
                  <div class="text-admin-muted">Path:</div>
                  <div>
                    <code class="bg-admin-card px-1.5 py-0.5 rounded"
                      >/path/to/artis/files/originals/</code
                    >
                  </div>
                </div>
                <p class="text-xs text-admin-muted mt-3">
                  Use your server SSH credentials. Contact your hosting provider
                  if you need help setting up SFTP access.
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Upload queue -->
    <div id="queue-section" class="hidden">
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-lg font-semibold">Upload Queue</h3>
        <div class="flex items-center gap-4">
          <div id="publish-toggle-container">
            <Toggle
              client:load
              name="publishOnImport"
              label="Publish on import"
              defaultPressed={publishOnImportDefault}
            />
          </div>
          <div class="flex gap-4">
            <button id="upload-all-btn" class="btn btn-primary">
              üì§ Upload Image(s)
            </button>
            <button id="clear-queue-btn" class="btn btn-secondary">
              Clear Queue
            </button>
          </div>
        </div>
      </div>

      <div
        id="upload-queue"
        class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
      >
      </div>
    </div>

    <!-- Upload Results -->
    <div id="results-section" class="hidden">
      <div
        id="results-error-banner"
        class="hidden card border border-red-500/30 bg-red-500/10 text-red-200 p-4 mb-4 flex flex-wrap items-start justify-between gap-4"
      >
        <div class="space-y-1">
          <p class="font-semibold">Credentials required to continue</p>
          <p id="results-error-text" class="text-sm text-red-200/90"></p>
        </div>
        <Button
          id="open-secrets-vault-btn"
          type="button"
          variant="primary-light"
          class="whitespace-nowrap"
        >
          <Lock className="w-4 h-4" />
          <span>Open Secrets Vault</span>
        </Button>
      </div>
      <div class="flex items-center justify-between mb-4">
        <div class="flex items-center gap-3">
          <h3 class="text-lg font-semibold">Ready to Process</h3>
          <span
            class="bg-blue-500/10 text-blue-400 text-xs px-2 py-1 rounded-full border border-blue-500/20"
            >Uploaded to Server</span
          >
        </div>
        <div class="flex gap-4">
          <button id="process-all-btn" class="btn btn-primary">
            ‚ö° Process All & Create Artworks
          </button>
          <button id="clear-results-btn" class="btn btn-secondary">
            Dismiss
          </button>
        </div>
      </div>

      <div id="results" class="space-y-2"></div>
    </div>

    <!-- Scan Results (For FTP/SFTP) -->
    <div
      id="scan-results-section"
      class="hidden card bg-admin-accent/5 border-admin-accent/20"
    >
      <div class="flex items-center justify-between mb-4">
        <div class="flex items-center gap-3">
          <h3 class="text-lg font-semibold">Found in Files</h3>
          <span
            id="scan-count"
            class="bg-admin-accent text-white text-xs px-2 py-1 rounded-full"
            >0</span
          >
        </div>
        <div class="flex items-center gap-4">
          <div id="scan-publish-toggle-container">
            <Toggle
              client:load
              name="scanPublishOnImport"
              label="Publish on import"
              defaultPressed={publishOnImportDefault}
            />
          </div>
          <button id="process-scanned-btn" class="btn btn-primary">
            ‚ö° Process & Catalog These
          </button>
        </div>
      </div>
      <p class="text-sm text-admin-muted mb-4">
        These images were found in the <code class="bg-admin-card px-1 rounded"
          >files/originals/</code
        > folder but aren't in your gallery yet.
      </p>
      <div
        id="scan-results"
        class="max-h-48 overflow-y-auto bg-admin-bg/50 rounded-lg p-3 text-xs font-mono text-admin-muted"
      >
      </div>
    </div>
  </div>

  <Modal id="info-modal" title="Results" confirmText="OK" showActions={true}>
    <div id="info-modal-content"></div>
  </Modal>
</AdminLayout>

<style is:global>
  .collapsible-section {
    position: relative;
  }

  .collapsible-header {
    transition: all 0.2s ease;
    cursor: pointer;
  }

  .collapsible-header:hover {
    transform: none;
  }

  .collapsible-section:not(.collapsed) .collapsible-header {
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
  }

  .collapsible-section:not(.collapsed) .collapsible-header {
    border-bottom: 1px solid var(--admin-border, #2a2a2a);
  }

  /* Show full content when expanded, show minimal header when collapsed */
  .collapsible-section.collapsed .collapsible-header {
    display: flex;
  }

  .collapsible-section:not(.collapsed) .collapsible-header {
    display: none;
  }

  .collapsible-content {
    overflow: hidden;
    transition:
      max-height 0.3s ease,
      opacity 0.2s ease;
    max-height: 2000px;
    opacity: 1;
  }

  .collapsible-section.collapsed .collapsible-content {
    max-height: 0;
    opacity: 0;
    margin-top: 0;
  }

  .collapsible-section.collapsed .collapse-chevron {
    transform: rotate(-90deg);
  }

  .collapsible-section.collapsed .collapse-chevron {
    transform: rotate(-90deg);
  }

  /* Collapsed header states */
  .collapsible-header .collapse-indicator {
    opacity: 0;
    transition: opacity 0.2s ease;
  }

  .collapsible-section.collapsed .collapse-indicator-collapsed {
    opacity: 1;
  }

  .collapsible-section:not(.collapsed) .collapse-indicator-expanded {
    opacity: 1;
  }

  /* Smooth hover effects */
  .collapsible-header:hover .collapse-indicator {
    opacity: 1;
  }

  #drop-zone.dragover {
    border-color: var(--color-accent, #e94560);
    background: rgba(233, 69, 96, 0.1);
  }

  .queue-item {
    display: flex;
    flex-direction: column;
    padding: 16px;
    background: var(--admin-card);
    border-radius: 12px;
    border: 1px solid var(--admin-border);
  }

  .queue-item-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 12px;
    margin-bottom: 8px;
  }

  .queue-item-preview-wrapper {
    position: relative;
    border-radius: 8px;
    overflow: hidden;
  }

  .queue-item-preview {
    width: 100%;
    max-height: 140px;
    height: auto;
    aspect-ratio: 4/3;
    object-fit: cover;
    display: block;
  }

  .queue-item-info {
    flex: 1;
    min-width: 0;
  }

  .queue-item-name {
    font-weight: 500;
    word-break: break-all;
    font-size: 14px;
    margin-bottom: 2px;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .queue-item-size {
    font-size: 12px;
    color: var(--admin-muted);
  }

  .queue-item-remove {
    position: absolute;
    top: 8px;
    right: 8px;
    background: rgba(0, 0, 0, 0.8);
    border: none;
    color: var(--admin-accent);
    cursor: pointer;
    font-size: 24px;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 6px;
    transition: all 0.2s;
    flex-shrink: 0;
    z-index: 10;
    line-height: 32px;
  }

  .queue-item-remove:hover {
    background: rgba(255, 107, 107, 0.9);
    color: white;
  }

  .results-item {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .results-thumb {
    width: 44px;
    height: 44px;
    border-radius: 10px;
    overflow: hidden;
    flex-shrink: 0;
    background: var(--admin-bg);
    border: 1px solid var(--admin-border);
  }

  .results-thumb img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
  }
</style>

<script define:vars={{ imageBaseUrl, publishOnImportDefault }}>
  const dropZone = document.getElementById("drop-zone");
  const fileInput = document.getElementById("file-input");
  const queueSection = document.getElementById("queue-section");
  const uploadQueue = document.getElementById("upload-queue");
  const resultsSection = document.getElementById("results-section");
  const results = document.getElementById("results");
  const resultsErrorBanner = document.getElementById("results-error-banner");
  const resultsErrorText = document.getElementById("results-error-text");
  const openSecretsVaultBtn = document.getElementById(
    "open-secrets-vault-btn",
  );
  const scanResultsSection = document.getElementById("scan-results-section");
  const scanResults = document.getElementById("scan-results");
  const scanCount = document.getElementById("scan-count");
  const infoModal = document.getElementById("info-modal");
  const infoModalContent = document.getElementById(
    "info-modal-content",
  );
  const infoModalTitle = document.getElementById(
    "info-modal-title",
  );
  const publishToggleContainer = document.getElementById(
    "publish-toggle-container",
  );
  const scanPublishToggleContainer = document.getElementById(
    "scan-publish-toggle-container",
  );
  let publishOnImport = publishOnImportDefault;
  const secretsVaultErrorRegex = /(secrets? vault|credentials|r2)/i;

  // Handle collapse toggle buttons (chevrons)
  document.querySelectorAll(".collapse-toggle").forEach((toggle) => {
    toggle.addEventListener("click", (e) => {
      e.stopPropagation();
      const section = e.currentTarget?.closest(".collapsible-section");
      section?.classList.toggle("collapsed");
    });
  });

  // Click on upload header expands and opens file input (but not on chevron)
  const uploadHeader = document.querySelector('[data-collapse="upload"]');
  if (uploadHeader) {
    uploadHeader.addEventListener("click", (e) => {
      const target = e.target;
      // Don't trigger if clicking a button inside the header or the collapse toggle
      if (target?.closest?.("button") || target?.closest?.(".collapse-toggle"))
        return;

      const section = uploadHeader.closest(".collapsible-section");
      if (section?.classList.contains("collapsed")) {
        section.classList.remove("collapsed");
      }
      // Trigger file input click
      fileInput?.click();
    });

    uploadHeader.addEventListener("dragover", (e) => {
      e.preventDefault();
      uploadHeader.style.borderColor = "var(--color-accent, #e94560)";
      uploadHeader.style.background = "rgba(233, 69, 96, 0.1)";
    });
    uploadHeader.addEventListener("dragleave", () => {
      uploadHeader.style.borderColor = "";
      uploadHeader.style.background = "";
    });
    uploadHeader.addEventListener("drop", (e) => {
      e.preventDefault();
      uploadHeader.style.borderColor = "";
      uploadHeader.style.background = "";
      const files = e.dataTransfer?.files;
      if (files && files.length > 0) {
        // Keep section collapsed, just add files to queue
        addFiles(Array.from(files));
      }
    });
  }

  // Click on FTP header expands it (but doesn't trigger any action, just shows content)
  const ftpHeader = document.querySelector('[data-collapse="ftp"]');
  if (ftpHeader) {
    ftpHeader.addEventListener("click", (e) => {
      const target = e.target;
      // Don't trigger if clicking a button inside the header or the collapse toggle
      if (target?.closest?.("button") || target?.closest?.(".collapse-toggle"))
        return;

      const section = ftpHeader.closest(".collapsible-section");
      if (section?.classList.contains("collapsed")) {
        section.classList.remove("collapsed");
      }
    });
  }

  // Wire up collapsed FTP section buttons
  document
    .getElementById("scan-images-btn-collapsed")
    ?.addEventListener("click", () => {
      const ftpSection = document.getElementById("ftp-section");
      ftpSection?.classList.remove("collapsed");
      document.getElementById("scan-images-btn")?.click();
    });

  document
    .getElementById("show-ftp-details-collapsed")
    ?.addEventListener("click", () => {
      const ftpSection = document.getElementById("ftp-section");
      ftpSection?.classList.remove("collapsed");
      document.getElementById("show-ftp-details")?.click();
    });

  function updateToggleUI(container, isPressed) {
    const toggleRoot = container.querySelector(".toggle-root");
    const toggleThumb = container.querySelector(".toggle-thumb");

    if (isPressed) {
      toggleRoot?.classList.add("!bg-admin-bg");
      toggleRoot?.classList.remove("bg-admin-sidebar");
      toggleThumb?.classList.add("left-[26px]", "bg-admin-success");
      toggleThumb?.classList.remove("left-[4px]", "bg-white");
    } else {
      toggleRoot?.classList.remove("!bg-admin-bg");
      toggleRoot?.classList.add("bg-admin-sidebar");
      toggleThumb?.classList.remove("left-[26px]", "bg-admin-success");
      toggleThumb?.classList.add("left-[4px]", "bg-white");
    }

    // Store pressed state on the container for external access
    container.pressed = isPressed;
  }

  // Handle publish toggle changes
  publishToggleContainer?.addEventListener("click", async (e) => {
    const target = e.target;
    // Don't handle if clicking the toggle itself (it has its own handler)
    if (target?.closest?.(".toggle-root")) return;

    // Toggle the state
    publishOnImport = !publishOnImport;

    // Update toggle UI
    const toggleRoot = publishToggleContainer.querySelector(".toggle-root");
    const toggleThumb = publishToggleContainer.querySelector(".toggle-thumb");
    if (publishOnImport) {
      toggleRoot?.classList.add("!bg-admin-bg");
      toggleRoot?.classList.remove("bg-admin-sidebar");
      toggleThumb?.classList.add("left-[26px]", "bg-admin-success");
      toggleThumb?.classList.remove("left-[4px]", "bg-white");
    } else {
      toggleRoot?.classList.remove("!bg-admin-bg");
      toggleRoot?.classList.add("bg-admin-sidebar");
      toggleThumb?.classList.remove("left-[26px]", "bg-admin-success");
      toggleThumb?.classList.add("left-[4px]", "bg-white");
    }

    publishToggleContainer.pressed = publishOnImport;

    // Persist to settings
    try {
      await fetch("/api/settings", {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ "gallery.publishOnImport": publishOnImport }),
      });
    } catch (e) {
      console.error("Failed to save publishOnImport setting:", e);
    }
  });

  // Also handle clicks on the toggle root itself
  document
    .querySelectorAll("#publish-toggle-container .toggle-root")
    .forEach((toggle) => {
      toggle.addEventListener("click", async (e) => {
        e.stopPropagation();
        // Toggle state
        publishOnImport = !publishOnImport;

        // Update both toggles UI
        if (publishToggleContainer)
          updateToggleUI(publishToggleContainer, publishOnImport);
        if (scanPublishToggleContainer)
          updateToggleUI(scanPublishToggleContainer, publishOnImport);

        // Persist to settings
        try {
          await fetch("/api/settings", {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              "gallery.publishOnImport": publishOnImport,
            }),
          });
        } catch (e) {
          console.error("Failed to save publishOnImport setting:", e);
        }
      });
    });

  // Handle scan results publish toggle changes
  scanPublishToggleContainer?.addEventListener("click", async (e) => {
    const target = e.target;
    if (target?.closest?.(".toggle-root")) return;

    publishOnImport = !publishOnImport;

    // Update both toggles UI
    if (publishToggleContainer)
      updateToggleUI(publishToggleContainer, publishOnImport);
    if (scanPublishToggleContainer)
      updateToggleUI(scanPublishToggleContainer, publishOnImport);

    try {
      await fetch("/api/settings", {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ "gallery.publishOnImport": publishOnImport }),
      });
    } catch (e) {
      console.error("Failed to save publishOnImport setting:", e);
    }
  });

  // Handle clicks on scan toggle root
  document
    .querySelectorAll("#scan-publish-toggle-container .toggle-root")
    .forEach((toggle) => {
      toggle.addEventListener("click", async (e) => {
        e.stopPropagation();
        publishOnImport = !publishOnImport;

        // Update both toggles UI
        if (publishToggleContainer)
          updateToggleUI(publishToggleContainer, publishOnImport);
        if (scanPublishToggleContainer)
          updateToggleUI(scanPublishToggleContainer, publishOnImport);

        try {
          await fetch("/api/settings", {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              "gallery.publishOnImport": publishOnImport,
            }),
          });
        } catch (e) {
          console.error("Failed to save publishOnImport setting:", e);
        }
      });
    });

  function setInfoModalCancelVisible(visible) {
    const cancelBtn = infoModal?.querySelector(
      "[data-modal-cancel]",
    );
    if (!cancelBtn) return;
    if (visible) cancelBtn.classList.remove("hidden");
    else cancelBtn.classList.add("hidden");
  }

  infoModal?.addEventListener("confirm", () => {
    infoModal?.close?.();
  });

  let files = [];

  // Click to select
  dropZone?.addEventListener("click", () => fileInput?.click());

  // File input change
  fileInput?.addEventListener("change", (e) => {
    const input = e.target;
    if (input?.files) {
      addFiles(Array.from(input.files));
    }
  });

  // Drag and drop
  dropZone?.addEventListener("dragover", (e) => {
    e.preventDefault();
    dropZone.classList.add("dragover");
  });

  dropZone?.addEventListener("dragleave", () => {
    dropZone.classList.remove("dragover");
  });

  dropZone?.addEventListener("drop", (e) => {
    e.preventDefault();
    dropZone.classList.remove("dragover");
    if (e.dataTransfer?.files) {
      addFiles(Array.from(e.dataTransfer.files));
    }
  });

  function getFileSignature(file) {
    return `${file.name}|${file.size}|${file.lastModified}`;
  }

  function addFiles(newFiles) {
    // Filter to images only
    const imageFiles = newFiles.filter((f) =>
      /\.(jpg|jpeg|png|tiff|tif|heic|heif|webp)$/i.test(f.name),
    );
    const existingSignatures = new Set(files.map(getFileSignature));
    const uniqueFiles = imageFiles.filter(
      (file) => !existingSignatures.has(getFileSignature(file)),
    );

    if (uniqueFiles.length > 0) {
      // Collapse both upload and FTP sections when images are added
      document.getElementById("ftp-section")?.classList.add("collapsed");
      document.getElementById("upload-section")?.classList.add("collapsed");
    }

    files.unshift(...uniqueFiles);
    renderQueue();
  }

  function renderQueue() {
    if (!uploadQueue) return;

    uploadQueue.innerHTML = "";

    // Set dynamic grid columns based on file count
    let gridColsClass = "grid-cols-1 md:grid-cols-2 lg:grid-cols-3";
    if (files.length === 4) {
      gridColsClass = "grid-cols-1 md:grid-cols-2 lg:grid-cols-4";
    } else if (files.length >= 5) {
      gridColsClass = "grid-cols-1 md:grid-cols-3 lg:grid-cols-5";
    }

    // Remove old grid classes and add new one
    uploadQueue.className = `grid ${gridColsClass} gap-4`;

    files.forEach((file, index) => {
      const item = document.createElement("div");
      item.className = "queue-item";

      item.innerHTML = `
        <div class="queue-item-header">
          <div class="queue-item-info">
            <div class="queue-item-name clamp-2">${file.name}</div>
            <div class="queue-item-size">${(file.size / 1024 / 1024).toFixed(2)} MB</div>
          </div>
        </div>
        <div class="queue-item-preview-wrapper">
          <img class="queue-item-preview" src="${URL.createObjectURL(file)}" alt="" />
          <button class="queue-item-remove" data-index="${index}" title="Remove">√ó</button>
        </div>
      `;

      uploadQueue.appendChild(item);
    });

    // Show/hide queue section
    if (queueSection) {
      queueSection.classList.toggle("hidden", files.length === 0);
    }

    // Update top toolbar
  }

  // Remove from queue
  uploadQueue?.addEventListener("click", (e) => {
    const target = e.target;
    if (!(target instanceof HTMLElement)) return;
    if (target.classList.contains("queue-item-remove")) {
      const index = parseInt(target.dataset.index || "0");
      files.splice(index, 1);
      renderQueue();
    }
  });

  // Clear queue
  document.getElementById("clear-queue-btn")?.addEventListener("click", () => {
    files = [];
    renderQueue();
  });

  // Upload all
  document
    .getElementById("upload-all-btn")
    ?.addEventListener("click", async () => {
      const btn = document.getElementById("upload-all-btn");
      if (!btn) return;
      btn.disabled = true;
      btn.textContent = "‚è≥ Uploading...";

      const formData = new FormData();
      files.forEach((file) => formData.append("images", file));
      formData.append("publishOnImport", publishOnImport.toString());

      try {
        const res = await fetch("/api/upload", {
          method: "POST",
          body: formData,
        });

        const data = await res.json();

        // Show results
        if (results && resultsSection) {
          results.innerHTML =
            data.uploaded
              ?.map((u) => {
                const thumbUrl = imageBaseUrl
                  ? `${imageBaseUrl}/thumbnails/${u.slug}.png`
                  : `/thumbnails/${u.slug}.png`;
                return `
          <div class="card p-3 results-item">
            <div class="results-thumb">
              <img src="${thumbUrl}" alt="${u.filename}" loading="lazy" />
            </div>
            <div class="text-sm">${u.filename}</div>
          </div>
        `;
              })
              .join("") || "";

          if (data.errors?.length) {
            const secretsError = data.errors.find((e) =>
              secretsVaultErrorRegex.test(e),
            );
            if (secretsError && resultsErrorBanner && resultsErrorText) {
              resultsErrorText.textContent = secretsError.replace(
                /^[^:]+:\s*/,
                "",
              );
              resultsErrorBanner.classList.remove("hidden");
            } else if (resultsErrorBanner) {
              resultsErrorBanner.classList.add("hidden");
            }
          } else if (resultsErrorBanner) {
            resultsErrorBanner.classList.add("hidden");
          }

          resultsSection.classList.remove("hidden");
        }

        // Remove successfully uploaded files from queue
        if (Array.isArray(data.uploaded) && data.uploaded.length > 0) {
          const uploadedNames = new Set(
            data.uploaded.map((u) => u.filename),
          );
          files = files.filter((file) => !uploadedNames.has(file.name));
        }
        renderQueue();
      } catch (e) {
        window.dispatchEvent(
          new CustomEvent("artsitemaker:toast", {
            detail: {
              title: "Upload failed",
              description: "An unexpected error occurred.",
              variant: "destructive",
            },
          }),
        );
      } finally {
        btn.disabled = false;
        btn.textContent = "üì§ Upload Image(s)";
      }
    });

  // Global process logic (reused for both upload and scan)
  async function runProcessing(buttonId) {
    const btn = document.getElementById(buttonId);
    if (!btn) return;
    const originalText = btn.textContent;
    btn.disabled = true;
    btn.textContent = "‚è≥ Processing...";

    try {
      const res = await fetch("/api/process", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({}), // Processes all uncataloged
      });

      const data = await res.json();

      if (data && infoModalTitle && infoModalContent) {
        infoModalTitle.textContent = "Processing Complete";
        infoModalContent.innerHTML = `
          <div class="flex flex-col gap-4">
            <div class="flex items-center gap-3 text-green-400">
              <span class="text-3xl">‚ú®</span>
              <p class="text-lg font-semibold">Successfully processed ${data.processed?.length || 0} images!</p>
            </div>
            <div class="bg-admin-bg/50 rounded-lg p-4 space-y-3">
              <p class="text-sm">Here's what happened behind the scenes:</p>
              <ul class="text-sm text-admin-muted space-y-2">
                <li class="flex gap-2">
                  <span class="text-admin-accent">‚Ä¢</span>
                  <span><strong>Optimized:</strong> Generated web-ready versions (WebP/AVIF) in multiple sizes.</span>
                </li>
                <li class="flex gap-2">
                  <span class="text-admin-accent">‚Ä¢</span>
                  <span><strong>Cataloged:</strong> Created new database entries for each artwork.</span>
                </li>
                <li class="flex gap-2">
                  <span class="text-admin-accent">‚Ä¢</span>
                  <span><strong>Organized:</strong> Moved original files to permanent storage.</span>
                </li>
              </ul>
            </div>
            <p class="text-sm text-admin-muted italic">You can now head to the gallery to add details, prices, and organize your collection.</p>
          </div>
        `;

        setInfoModalCancelVisible(true);
        const confirmBtn = infoModal.querySelector(".confirm-modal");
        if (confirmBtn) confirmBtn.textContent = "Go to Gallery";

        infoModal.open();

        infoModal.addEventListener(
          "confirm",
          () => {
            window.location.href = "/gallery";
          },
          { once: true },
        );
      }
    } catch (e) {
      window.dispatchEvent(
        new CustomEvent("artsitemaker:toast", {
          detail: {
            title: "Processing failed",
            description: "An unexpected error occurred.",
            variant: "destructive",
          },
        }),
      );
    } finally {
      btn.disabled = false;
      btn.textContent = originalText;
    }
  }

  // Process all button (from upload)
  document.getElementById("process-all-btn")?.addEventListener("click", () => {
    runProcessing("process-all-btn");
  });

  // Process scanned button (from FTP scan)
  document
    .getElementById("process-scanned-btn")
    ?.addEventListener("click", () => {
      runProcessing("process-scanned-btn");
    });

  // Clear results
  document
    .getElementById("clear-results-btn")
    ?.addEventListener("click", () => {
      if (resultsSection) {
        resultsSection.classList.add("hidden");
        if (resultsErrorBanner) {
          resultsErrorBanner.classList.add("hidden");
        }
      }
    });

  // Toggle FTP details
  document.getElementById("show-ftp-details")?.addEventListener("click", () => {
    const details = document.getElementById("ftp-details");
    details?.classList.toggle("hidden");
  });

  // Scan for new images
  document
    .getElementById("scan-images-btn")
    ?.addEventListener("click", async () => {
    const btn = document.getElementById("scan-images-btn");
    if (!btn) return;
      btn.disabled = true;
      btn.textContent = "üîç Scanning...";

      try {
        const res = await fetch("/api/scan", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({}),
        });

        const data = await res.json();

        if (data.found?.length > 0) {
          if (scanResultsSection && scanResults && scanCount) {
            scanCount.textContent = data.found.length.toString();
            scanResults.innerHTML = data.found
              .map((f) => `<div>${f}</div>`)
              .join("");
            scanResultsSection.classList.remove("hidden");
            scanResultsSection.scrollIntoView({ behavior: "smooth" });
          }
        } else if (infoModalTitle && infoModalContent) {
          infoModalTitle.textContent = "Scan Results";
          infoModalContent.innerHTML = `
          <div class="text-center py-4">
            <div class="text-4xl mb-4">‚àÖ</div>
            <p>No new images found in <code class="bg-admin-card px-1 rounded">files/originals/</code></p>
          </div>
        `;
          setInfoModalCancelVisible(false);
          const confirmBtn = infoModal.querySelector(".confirm-modal");
          if (confirmBtn) confirmBtn.textContent = "OK";
          infoModal.open();
        }
      } catch (e) {
        window.dispatchEvent(
          new CustomEvent("artsitemaker:toast", {
            detail: {
              title: "Scan failed",
              description: "Make sure the files/originals/ folder exists.",
              variant: "destructive",
            },
          }),
        );
      } finally {
        btn.disabled = false;
        btn.textContent = "üîç Scan for New Images";
      }
    });

  openSecretsVaultBtn?.addEventListener("click", () => {
    window.openSecretsVault?.();
  });
</script>
